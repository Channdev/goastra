/*
 * GoAstra CLI - GraphQL Generator
 *
 * Generates GraphQL schema extensions and resolvers for new resources.
 * Works with gqlgen to add queries and mutations.
 */
package generator

import (
	"fmt"
	"os"
	"path/filepath"
)

/*
 * GraphQLGenerator handles GraphQL schema and resolver generation.
 */
type GraphQLGenerator struct {
	name       string
	pascalName string
	camelName  string
}

/*
 * NewGraphQLGenerator creates a new GraphQL generator instance.
 */
func NewGraphQLGenerator(name string) *GraphQLGenerator {
	return &GraphQLGenerator{
		name:       name,
		pascalName: toPascalCase(name),
		camelName:  toCamelCase(name),
	}
}

/*
 * GenerateSchema creates a GraphQL schema file for the resource.
 */
func (g *GraphQLGenerator) GenerateSchema() error {
	content := fmt.Sprintf(`# %s GraphQL Schema
#
# Generated by GoAstra CLI
# Add this to your main schema.graphqls or keep as separate file

# ============================================================================
# %s QUERIES
# ============================================================================

extend type Query {
  """Get a %s by ID"""
  %s(id: ID!): %s

  """List %s with pagination"""
  %ss(page: Int = 1, pageSize: Int = 20): %sConnection!
}

# ============================================================================
# %s MUTATIONS
# ============================================================================

extend type Mutation {
  """Create a new %s"""
  create%s(input: Create%sInput!): %s!

  """Update an existing %s"""
  update%s(id: ID!, input: Update%sInput!): %s!

  """Delete a %s"""
  delete%s(id: ID!): Boolean!
}

# ============================================================================
# %s TYPES
# ============================================================================

"""%s entity"""
type %s {
  id: ID!
  # TODO: Add your fields here
  # name: String!
  # description: String
  createdAt: String!
  updatedAt: String!
}

"""Paginated list of %s"""
type %sConnection {
  data: [%s!]!
  total: Int!
  page: Int!
  pageSize: Int!
  totalPages: Int!
}

# ============================================================================
# %s INPUTS
# ============================================================================

"""Input for creating a %s"""
input Create%sInput {
  # TODO: Add your create input fields here
  # name: String!
  # description: String
}

"""Input for updating a %s"""
input Update%sInput {
  # TODO: Add your update input fields here
  # name: String
  # description: String
}
`,
		g.pascalName,
		g.pascalName,
		g.name, g.camelName, g.pascalName,
		g.name, g.camelName, g.pascalName,
		g.pascalName,
		g.name,
		g.pascalName, g.pascalName, g.pascalName,
		g.name,
		g.pascalName, g.pascalName, g.pascalName,
		g.name,
		g.pascalName,
		g.pascalName,
		g.pascalName,
		g.pascalName,
		g.name,
		g.pascalName, g.pascalName,
		g.pascalName,
		g.name,
		g.pascalName,
		g.name,
		g.pascalName,
	)

	path := filepath.Join("app/graph", g.name+".graphqls")
	return os.WriteFile(path, []byte(content), 0644)
}

/*
 * GenerateResolver creates resolver implementations for the resource.
 */
func (g *GraphQLGenerator) GenerateResolver() error {
	content := fmt.Sprintf(`/*
 * %s Resolvers
 *
 * GraphQL resolver implementations for %s operations.
 * Generated by GoAstra CLI
 */
package graph

import (
	"context"
	"errors"

	"app/graph/model"
)

// ============================================================================
// %s QUERY RESOLVERS
// ============================================================================

/*
 * %s returns a single %s by ID.
 */
func (r *queryResolver) %s(ctx context.Context, id string) (*model.%s, error) {
	// TODO: Implement %s lookup
	return nil, errors.New("not implemented")
}

/*
 * %ss returns a paginated list of %s.
 */
func (r *queryResolver) %ss(ctx context.Context, page *int, pageSize *int) (*model.%sConnection, error) {
	p := 1
	ps := 20
	if page != nil {
		p = *page
	}
	if pageSize != nil {
		ps = *pageSize
	}

	// TODO: Implement %s listing with pagination
	return &model.%sConnection{
		Data:       []*model.%s{},
		Total:      0,
		Page:       p,
		PageSize:   ps,
		TotalPages: 0,
	}, nil
}

// ============================================================================
// %s MUTATION RESOLVERS
// ============================================================================

/*
 * Create%s creates a new %s.
 */
func (r *mutationResolver) Create%s(ctx context.Context, input model.Create%sInput) (*model.%s, error) {
	// TODO: Implement %s creation
	return nil, errors.New("not implemented")
}

/*
 * Update%s updates an existing %s.
 */
func (r *mutationResolver) Update%s(ctx context.Context, id string, input model.Update%sInput) (*model.%s, error) {
	// TODO: Implement %s update
	return nil, errors.New("not implemented")
}

/*
 * Delete%s deletes a %s by ID.
 */
func (r *mutationResolver) Delete%s(ctx context.Context, id string) (bool, error) {
	// TODO: Implement %s deletion
	return false, errors.New("not implemented")
}
`,
		g.pascalName, g.name,
		g.pascalName,
		g.pascalName, g.name,
		g.pascalName, g.pascalName,
		g.name,
		g.pascalName, g.name,
		g.pascalName, g.pascalName,
		g.name,
		g.pascalName, g.pascalName,
		g.pascalName,
		g.pascalName, g.name,
		g.pascalName, g.pascalName, g.pascalName,
		g.name,
		g.pascalName, g.name,
		g.pascalName, g.pascalName, g.pascalName,
		g.name,
		g.pascalName, g.name,
		g.pascalName,
		g.name,
	)

	path := filepath.Join("app/graph", g.name+".resolvers.go")
	return os.WriteFile(path, []byte(content), 0644)
}

/*
 * GenerateAll generates both schema and resolvers.
 */
func (g *GraphQLGenerator) GenerateAll() error {
	if err := g.GenerateSchema(); err != nil {
		return err
	}
	return g.GenerateResolver()
}
