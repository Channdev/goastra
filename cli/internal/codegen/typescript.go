/*
 * GoAstra CLI - TypeScript Generator
 *
 * Converts Go type definitions to TypeScript interfaces.
 * Generates type-safe models for Angular frontend.
 */
package codegen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

/*
 * TypeScriptGenerator creates TypeScript files from Go types.
 */
type TypeScriptGenerator struct {
	outputPath string
}

/*
 * NewTypeScriptGenerator creates a new generator instance.
 */
func NewTypeScriptGenerator(outputPath string) *TypeScriptGenerator {
	return &TypeScriptGenerator{outputPath: outputPath}
}

/*
 * Generate creates TypeScript interface files for all types.
 */
func (g *TypeScriptGenerator) Generate(types []TypeDef) error {
	if err := os.MkdirAll(g.outputPath, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	/* Generate individual type files */
	for _, typeDef := range types {
		if err := g.generateTypeFile(typeDef); err != nil {
			return err
		}
	}

	/* Generate index barrel file */
	return g.generateIndex(types)
}

func (g *TypeScriptGenerator) generateTypeFile(typeDef TypeDef) error {
	var sb strings.Builder

	sb.WriteString("/*\n")
	if typeDef.Doc != "" {
		sb.WriteString(fmt.Sprintf(" * %s", typeDef.Doc))
	} else {
		sb.WriteString(fmt.Sprintf(" * %s interface\n", typeDef.Name))
	}
	sb.WriteString(" * Auto-generated by GoAstra typesync\n")
	sb.WriteString(" */\n\n")

	sb.WriteString(fmt.Sprintf("export interface %s {\n", typeDef.Name))

	for _, field := range typeDef.Fields {
		tsType := g.goTypeToTS(field.Type)
		jsonName := field.JSONName
		if jsonName == "" {
			jsonName = toCamelCaseTS(field.Name)
		}

		optionalMarker := ""
		if field.Optional {
			optionalMarker = "?"
		}

		if field.Doc != "" {
			sb.WriteString(fmt.Sprintf("  /* %s */\n", strings.TrimSpace(field.Doc)))
		}

		sb.WriteString(fmt.Sprintf("  %s%s: %s;\n", jsonName, optionalMarker, tsType))
	}

	sb.WriteString("}\n")

	filename := toKebabCase(typeDef.Name) + ".interface.ts"
	path := filepath.Join(g.outputPath, filename)

	return os.WriteFile(path, []byte(sb.String()), 0644)
}

func (g *TypeScriptGenerator) generateIndex(types []TypeDef) error {
	var sb strings.Builder

	sb.WriteString("/*\n")
	sb.WriteString(" * GoAstra Models - Barrel Export\n")
	sb.WriteString(" * Auto-generated by GoAstra typesync\n")
	sb.WriteString(" */\n\n")

	for _, typeDef := range types {
		filename := toKebabCase(typeDef.Name) + ".interface"
		sb.WriteString(fmt.Sprintf("export * from './%s';\n", filename))
	}

	path := filepath.Join(g.outputPath, "index.ts")
	return os.WriteFile(path, []byte(sb.String()), 0644)
}

/*
 * goTypeToTS converts a Go type string to TypeScript type.
 */
func (g *TypeScriptGenerator) goTypeToTS(goType string) string {
	/* Handle pointers */
	if strings.HasPrefix(goType, "*") {
		return g.goTypeToTS(goType[1:]) + " | null"
	}

	/* Handle slices */
	if strings.HasPrefix(goType, "[]") {
		return g.goTypeToTS(goType[2:]) + "[]"
	}

	/* Handle maps */
	if strings.HasPrefix(goType, "map[") {
		/* Extract key and value types */
		inner := goType[4 : len(goType)-1]
		parts := strings.SplitN(inner, "]", 2)
		if len(parts) == 2 {
			keyType := g.goTypeToTS(parts[0])
			valType := g.goTypeToTS(parts[1])
			return fmt.Sprintf("Record<%s, %s>", keyType, valType)
		}
		return "Record<string, unknown>"
	}

	/* Basic type mappings */
	switch goType {
	case "string":
		return "string"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return "number"
	case "bool":
		return "boolean"
	case "interface{}", "any":
		return "unknown"
	case "time.Time":
		return "string"
	case "Time":
		return "string"
	default:
		/* Check for time package types */
		if strings.HasPrefix(goType, "time.") {
			return "string"
		}
		/* Assume custom type reference */
		return goType
	}
}

func toCamelCaseTS(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(string(s[0])) + s[1:]
}

func toKebabCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('-')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}
