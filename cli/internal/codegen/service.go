/*
 * GoAstra CLI - Service Generator
 *
 * Generates Angular services from Go type definitions.
 * Creates type-safe API clients with CRUD operations.
 */
package codegen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

/*
 * ServiceGenerator creates Angular service files from Go types.
 */
type ServiceGenerator struct {
	outputPath string
}

/*
 * NewServiceGenerator creates a new generator instance.
 */
func NewServiceGenerator(outputPath string) *ServiceGenerator {
	return &ServiceGenerator{outputPath: outputPath}
}

/*
 * Generate creates Angular service files for applicable types.
 */
func (g *ServiceGenerator) Generate(types []TypeDef) error {
	servicePath := filepath.Join(filepath.Dir(g.outputPath), "services", "generated")
	if err := os.MkdirAll(servicePath, 0755); err != nil {
		return fmt.Errorf("failed to create services directory: %w", err)
	}

	for _, typeDef := range types {
		/* Skip utility types */
		if g.isUtilityType(typeDef.Name) {
			continue
		}

		if err := g.generateService(typeDef, servicePath); err != nil {
			return err
		}
	}

	return g.generateServicesIndex(types, servicePath)
}

func (g *ServiceGenerator) isUtilityType(name string) bool {
	utilityTypes := []string{
		"BaseModel",
		"PaginatedResponse",
		"APIError",
	}

	for _, ut := range utilityTypes {
		if name == ut {
			return true
		}
	}

	return false
}

func (g *ServiceGenerator) generateService(typeDef TypeDef, servicePath string) error {
	var sb strings.Builder

	kebabName := toKebabCase(typeDef.Name)
	pluralName := toPlural(kebabName)

	sb.WriteString("/*\n")
	sb.WriteString(fmt.Sprintf(" * %s API Service\n", typeDef.Name))
	sb.WriteString(" * Auto-generated by GoAstra typesync\n")
	sb.WriteString(" */\n")
	sb.WriteString("import { Injectable } from '@angular/core';\n")
	sb.WriteString("import { Observable } from 'rxjs';\n")
	sb.WriteString("import { ApiService } from '@core/services/api.service';\n")
	sb.WriteString(fmt.Sprintf("import { %s } from '@core/models';\n\n", typeDef.Name))

	/* Paginated response interface */
	sb.WriteString(fmt.Sprintf("export interface %sPaginatedResponse {\n", typeDef.Name))
	sb.WriteString(fmt.Sprintf("  data: %s[];\n", typeDef.Name))
	sb.WriteString("  total: number;\n")
	sb.WriteString("  page: number;\n")
	sb.WriteString("  pageSize: number;\n")
	sb.WriteString("  totalPages: number;\n")
	sb.WriteString("}\n\n")

	/* Create DTO */
	sb.WriteString(fmt.Sprintf("export interface Create%sDto {\n", typeDef.Name))
	for _, field := range typeDef.Fields {
		if g.isCreateField(field) {
			tsType := g.goTypeToTS(field.Type)
			jsonName := field.JSONName
			if jsonName == "" {
				jsonName = toCamelCaseTS(field.Name)
			}
			sb.WriteString(fmt.Sprintf("  %s: %s;\n", jsonName, tsType))
		}
	}
	sb.WriteString("}\n\n")

	/* Update DTO */
	sb.WriteString(fmt.Sprintf("export interface Update%sDto {\n", typeDef.Name))
	for _, field := range typeDef.Fields {
		if g.isUpdateField(field) {
			tsType := g.goTypeToTS(field.Type)
			jsonName := field.JSONName
			if jsonName == "" {
				jsonName = toCamelCaseTS(field.Name)
			}
			sb.WriteString(fmt.Sprintf("  %s?: %s;\n", jsonName, tsType))
		}
	}
	sb.WriteString("}\n\n")

	/* Service class */
	sb.WriteString("@Injectable({\n")
	sb.WriteString("  providedIn: 'root'\n")
	sb.WriteString("})\n")
	sb.WriteString(fmt.Sprintf("export class %sApiService {\n", typeDef.Name))
	sb.WriteString(fmt.Sprintf("  private readonly basePath = '/%s';\n\n", pluralName))

	sb.WriteString("  constructor(private api: ApiService) {}\n\n")

	/* List method */
	sb.WriteString(fmt.Sprintf("  list(page = 1, pageSize = 10): Observable<%sPaginatedResponse> {\n", typeDef.Name))
	sb.WriteString("    return this.api.get(this.basePath, {\n")
	sb.WriteString("      page: page.toString(),\n")
	sb.WriteString("      page_size: pageSize.toString()\n")
	sb.WriteString("    });\n")
	sb.WriteString("  }\n\n")

	/* GetById method */
	sb.WriteString(fmt.Sprintf("  getById(id: number): Observable<%s> {\n", typeDef.Name))
	sb.WriteString("    return this.api.get(`${this.basePath}/${id}`);\n")
	sb.WriteString("  }\n\n")

	/* Create method */
	sb.WriteString(fmt.Sprintf("  create(data: Create%sDto): Observable<%s> {\n", typeDef.Name, typeDef.Name))
	sb.WriteString("    return this.api.post(this.basePath, data);\n")
	sb.WriteString("  }\n\n")

	/* Update method */
	sb.WriteString(fmt.Sprintf("  update(id: number, data: Update%sDto): Observable<%s> {\n", typeDef.Name, typeDef.Name))
	sb.WriteString("    return this.api.put(`${this.basePath}/${id}`, data);\n")
	sb.WriteString("  }\n\n")

	/* Delete method */
	sb.WriteString("  delete(id: number): Observable<void> {\n")
	sb.WriteString("    return this.api.delete(`${this.basePath}/${id}`);\n")
	sb.WriteString("  }\n")

	sb.WriteString("}\n")

	filename := kebabName + "-api.service.ts"
	path := filepath.Join(servicePath, filename)

	return os.WriteFile(path, []byte(sb.String()), 0644)
}

func (g *ServiceGenerator) generateServicesIndex(types []TypeDef, servicePath string) error {
	var sb strings.Builder

	sb.WriteString("/*\n")
	sb.WriteString(" * GoAstra Generated Services - Barrel Export\n")
	sb.WriteString(" * Auto-generated by GoAstra typesync\n")
	sb.WriteString(" */\n\n")

	for _, typeDef := range types {
		if g.isUtilityType(typeDef.Name) {
			continue
		}
		kebabName := toKebabCase(typeDef.Name)
		sb.WriteString(fmt.Sprintf("export * from './%s-api.service';\n", kebabName))
	}

	path := filepath.Join(servicePath, "index.ts")
	return os.WriteFile(path, []byte(sb.String()), 0644)
}

func (g *ServiceGenerator) isCreateField(field FieldDef) bool {
	excludeFields := []string{"ID", "Id", "id", "CreatedAt", "UpdatedAt", "DeletedAt"}
	for _, ef := range excludeFields {
		if field.Name == ef {
			return false
		}
	}
	return true
}

func (g *ServiceGenerator) isUpdateField(field FieldDef) bool {
	excludeFields := []string{"ID", "Id", "id", "CreatedAt", "UpdatedAt", "DeletedAt"}
	for _, ef := range excludeFields {
		if field.Name == ef {
			return false
		}
	}
	return true
}

func (g *ServiceGenerator) goTypeToTS(goType string) string {
	if strings.HasPrefix(goType, "*") {
		return g.goTypeToTS(goType[1:]) + " | null"
	}

	if strings.HasPrefix(goType, "[]") {
		return g.goTypeToTS(goType[2:]) + "[]"
	}

	switch goType {
	case "string":
		return "string"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return "number"
	case "bool":
		return "boolean"
	case "interface{}", "any":
		return "unknown"
	case "time.Time", "Time":
		return "string"
	default:
		return goType
	}
}

func toPlural(s string) string {
	if strings.HasSuffix(s, "s") {
		return s + "es"
	}
	if strings.HasSuffix(s, "y") {
		return s[:len(s)-1] + "ies"
	}
	return s + "s"
}
